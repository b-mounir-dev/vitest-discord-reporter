import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import type { APIEmbed } from 'discord.js';
import { request } from 'undici';
import { sendDiscordMessage } from '../src/discord';

// Mock setup
const mocks = vi.hoisted(() => ({
  mockRequest: vi.fn(),
}));
vi.mock('undici', () => ({
  request: mocks.mockRequest,
}));

const mockWebhookUrl = 'https://discord.com/api/webhooks/123/abc';
const mockEmbeds: APIEmbed[] = [
  {
    title: 'Test Results',
    description: 'Test summary',
    color: 0x57f287,
    fields: [
      { name: 'Passed', value: '5', inline: true },
      { name: 'Failed', value: '0', inline: true },
    ],
  },
];

describe('discord', () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe('sendDiscordMessage', () => {
    it('should send a POST request with correct headers and body', async () => {
      const mockResponse = { statusCode: 204 };
      mocks.mockRequest.mockResolvedValue(mockResponse);

      const result = await sendDiscordMessage(mockWebhookUrl, mockEmbeds);

      expect(mocks.mockRequest).toHaveBeenCalledTimes(1);
      expect(mocks.mockRequest).toHaveBeenCalledWith(mockWebhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ embeds: mockEmbeds }),
      });
      expect(result).toBe(mockResponse);
    });

    it('should handle empty embeds array', async () => {
      const mockResponse = { statusCode: 204 };
      mocks.mockRequest.mockResolvedValue(mockResponse);

      await sendDiscordMessage(mockWebhookUrl, []);

      expect(mocks.mockRequest).toHaveBeenCalledWith(mockWebhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ embeds: [] }),
      });
    });

    it('should handle multiple embeds', async () => {
      const multipleEmbeds: APIEmbed[] = [
        { title: 'Summary', color: 0x57f287 },
        { title: 'Failed Tests', color: 0xed4245 },
        { title: 'Passed Tests', color: 0x57f287 },
      ];
      const mockResponse = { statusCode: 204 };
      mocks.mockRequest.mockResolvedValue(mockResponse);

      await sendDiscordMessage(mockWebhookUrl, multipleEmbeds);

      expect(mocks.mockRequest).toHaveBeenCalledWith(mockWebhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ embeds: multipleEmbeds }),
      });
    });

    it('should propagate request errors', async () => {
      const mockError = new Error('Network error');
      mocks.mockRequest.mockRejectedValue(mockError);

      await expect(sendDiscordMessage(mockWebhookUrl, mockEmbeds)).rejects.toThrow('Network error');
      expect(mocks.mockRequest).toHaveBeenCalledTimes(1);
    });

    it('should handle different webhook URLs', async () => {
      const differentUrl = 'https://discord.com/api/webhooks/456/def';
      const mockResponse = { statusCode: 204 };
      mocks.mockRequest.mockResolvedValue(mockResponse);

      await sendDiscordMessage(differentUrl, mockEmbeds);

      expect(mocks.mockRequest).toHaveBeenCalledWith(differentUrl, expect.any(Object));
    });

    it('should serialize complex embed objects correctly', async () => {
      const complexEmbed: APIEmbed = {
        title: 'Complex Test Results',
        description: 'Detailed test summary with **markdown**',
        color: 0x57f287,
        fields: [
          { name: 'Category 1', value: 'Value 1', inline: true },
          { name: 'Category 2', value: 'Value 2', inline: false },
        ],
        footer: { text: 'Generated by vitest-discord-reporter' },
        timestamp: new Date().toISOString(),
      };
      const mockResponse = { statusCode: 204 };
      mocks.mockRequest.mockResolvedValue(mockResponse);

      await sendDiscordMessage(mockWebhookUrl, [complexEmbed]);

      const callArgs = mocks.mockRequest.mock.calls[0];
      const bodyObj = JSON.parse(callArgs[1].body);
      expect(bodyObj.embeds[0]).toEqual(complexEmbed);
    });

    it('should return the response from undici request', async () => {
      const mockResponse = {
        statusCode: 204,
        headers: { 'content-type': 'application/json' },
        body: null
      };
      mocks.mockRequest.mockResolvedValue(mockResponse);

      const result = await sendDiscordMessage(mockWebhookUrl, mockEmbeds);

      expect(result).toEqual(mockResponse);
    });
  });
});

const HAS_WEBHOOK_URL = !!(process.env.VITE_DISCORD_WEBHOOK_URL?.trim());
describe.skipIf(!HAS_WEBHOOK_URL)('discord integration', () => {
  beforeEach(async () => {
    const undici = await vi.importActual<typeof import('undici')>('undici');
    vi.mocked(request).mockImplementation(undici.request);
  });

  it('should send a real message to Discord webhook', async () => {
    const webhookUrl = process.env.VITE_DISCORD_WEBHOOK_URL;
    const result = await sendDiscordMessage(webhookUrl!, mockEmbeds);
    expect(result.statusCode).toBe(204); // Discord returns 204 No Content on success
  });
});
